import React, { useState, useEffect, useRef, useMemo } from "react";

import { useIndicators } from "../../contexts/IndicatorsContext";
import { useAuth } from "../../contexts/UserAuth";
import fetchWithAuth from '../../../services/fetchWithAuth';

import IndexViewWrapper from "../reuseables/IndexView";
import ConfirmDelete from "../reuseables/ConfirmDelete";
import ComponentLoading from '../reuseables/loading/ComponentLoading';
import ButtonHover from "../reuseables/inputs/ButtonHover";
import Filter from '../reuseables/Filter';
import Messages from '../reuseables/Messages';

import styles from './tasks.module.css';

import { FaTrashAlt } from "react-icons/fa";
import Select from "../reuseables/inputs/Select";

//card that holds task details
function TaskCard({ task,  meta, onError, isDraggable = false, canDelete=false, onDelete=null, callback=null, forAssessment=false }) {
    /*
    Card that displays details about a Task
    - task (object): information about the task
    - meta (object): information about the indicators model
    - onError (function): pass errors generated by this task to the parent component
    - isDraggable (boolean, optional): is the user able to drag this card and drop it into another component
    - canDelete (boolean, optional): should this view show the delete button
    - onDelete (function, optional): what to do when this task is deleted
    - callback (function, optional): callback function that, when triggered, will pass this task to another component
    */
    //component meta
    const [errors, setErrors] = useState([]);
    const [del, setDel] = useState(false);
    const [expanded, setExpanded] = useState(false);

    //(for interactions) if this card should be draggable, mark it as such
    const handleDragStart = (e) => {
        e.dataTransfer.setData('application/json', JSON.stringify(task));
    };

    const type = task?.assessment ? 'assessment' : 'indicator';
    const typeLabel = task?.assessment ? 'Assessment' : 'Indicator';

    //pass errors up to parent if they arrise
    useEffect(() => {
        if(errors.length > 0){
            onError(errors);
        } 
    }, [errors]);

    //delete this task
    const removeTask = async() => {
        setErrors([]);
        try {
            console.log('deleting task...');
            const response = await fetchWithAuth(`/api/manage/tasks/${task.id}/`, {
                method: 'DELETE',
            });
            if (response.ok) {
                onDelete(task.id)
            } 
            else {
                let data = {};
                try {
                    data = await response.json();
                } 
                catch {
                    // no JSON body or invalid JSON
                    data = { detail: 'Unknown error occurred' };
                }

                const serverResponse = [];
                for (const field in data) {
                    if (Array.isArray(data[field])) {
                    data[field].forEach(msg => {
                        serverResponse.push(`${field}: ${msg}`);
                    });
                    } else {
                    serverResponse.push(`${field}: ${data[field]}`);
                    }
                }
                setErrors(serverResponse);
            }
        } 
        catch (err) {
            console.error('Failed to delete organization:', err);
            setErrors(['Something went wrong. Please try again later.'])
        }
        finally{
            setDel(false)
        }
    }

    //return delete seperately, since the card hover messes with the modal
    if(del){
        return(
            <div>
                {del && <div className={styles.backdrop}></div>}
                {del && 
                    <ConfirmDelete 
                        name={'Task ' + task.display_name + ' for' + task.organization.name } 
                        statusWarning={'If this task has any interactions associated with it, you will not be able to delete it.'} 
                        onConfirm={() => removeTask()} onCancel={() => setDel(false)} 
                />}
            </div>
        )

    }

    return (
        <div className={styles.card} onClick={() => setExpanded(!expanded)} 
            draggable={isDraggable} onDragStart={isDraggable ? handleDragStart : undefined}
        >
            <h3>{task.display_name}</h3>

            {callback && <button onClick={(e) => {callback(task); e.stopPropagation()}} type="button" style={{ maxHeight: 'fit-content' }}>
                {forAssessment ? `Start ${task?.assessment?.name} Assessent` : `Select ${task.display_name}`}
            </button>}
            
            {expanded && (
                <div>
                    {/* Display additional information about this tasks indicator for the user to reference */}
                    <p><strong>{typeLabel} Description:</strong> {task[type].description ? task[type].description : 'No description.'}</p>
                    {canDelete && <ButtonHover callback={() => setDel(true)} noHover={<FaTrashAlt />} hover={'Remove Task'} forDelete={true} />}
                </div>
            )}
        </div>
    );
}


export default function Tasks({ includeParams=[], excludeParams=[], isDraggable=false, blacklist=[], 
    canDelete=false, updateTrigger=null, callback=null, forAssessment=false, supportFilter=false
}) {
    /*
    Paginated index view that allows a user to view their tasks. 
    - includeParams (array, optional): array of objects like {field: 'name', value: value} that are passed to the 
        URL to filter list to only include certain results
    - excludeParams (array, optional): array of objects like {field: 'name', value: value} that are passed to the 
        URL to filter list to explicitly exclude certain results
    - isDraggable (boolean, optional): should the user be able to drag cards from this index component to another component
    - blacklist (array, optional): list of ids to hide from the user
    - canDelete (boolean, optional): should the delete button be viewable in this context
    - updateTrigger (integer/var, optional): trigger passed from parent that tells this component when to refetch
        the API to update the results
    - callback (function, optional): function that allows information abouta  specific task to be passed to another
        component
    - callbackText (string, optional): text to display on button that triggers callback function
    */
    const { indicatorsMeta, setIndicatorsMeta } = useIndicators();
    const { user } = useAuth();
    //the tasks themselves (usually not pulled in very large numbers)
    const [ tasks, setTasks ] = useState([]);
    //index helpers
    const [search, setSearch] = useState('');
    const [page, setPage] = useState(1);
    const [entries, setEntries] = useState(0);
    const [filters, setFilters] = useState({
        organization: user.organization_id,
        project: '',
    });
    //for filters
    const [orgSearch, setOrgSearch] = useState('');
    const [projectSearch, setProjectSearch] = useState('');
    const [projects, setProjects] = useState([]);
    const [orgs, setOrgs] = useState([]);

    //page meta
    const [loading, setLoading] = useState(true);
    const [success, setSuccess] = useState([])
    const [errors, setErrors] = useState([]);

    //scroll to errors
    const alertRef = useRef(null);
    useEffect(() => {
        if (errors.length > 0 && alertRef.current) {
        alertRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
        alertRef.current.focus({ preventScroll: true });
        }
    }, [errors]);

    //construct URL param strings from include/exclude param props
    const params = useMemo(() => {
        const allowedFields = ['organization', 'organizations', 'project', 'event', 'category', 'for_event'];
        const include = includeParams?.filter(p => allowedFields.includes(p?.field))
        ?.map(p => `&${p?.field}=${p?.value}`)
        .join('') ?? '';

        const exclude = excludeParams?.filter(p => allowedFields.includes(p?.field))
        ?.map(p => `&exclude_${p?.field}=${p?.value}`)
        .join('') ?? '';

        return include + exclude;
    }, [includeParams, excludeParams]);

    //get a list of the tasks
    useEffect(() => {
        const getTasks = async () => {
            try {
                console.log('fetching tasks...');
                //run the filters
                const filterQuery = supportFilter ? `&organization=${filters.organization}&project=${filters.project}` : '';
                const url = `/api/manage/tasks/?search=${search}&page=${page}` + filterQuery + params;
                console.log(url)
                const response = await fetchWithAuth(url);
                const data = await response.json();

                setTasks(data.results);
                setEntries(data.count); 
            } 
            catch (err) {
                console.error('Failed to delete organization:', err);
                setErrors(['Something went wrong. Please try again later.'])
            } 
            finally {
                setLoading(false);
            }
        };
        getTasks();
    }, [search, page, params, filters, updateTrigger]); //run on param changes or on parent request

    //fetch the model meta
    useEffect(() => {
        const getMeta = async () => {
            try {
                console.log('fetching meta...');
                //run the filters
                const url = `/api/indicators/manage/meta/`;
                const response = await fetchWithAuth(url);
                const data = await response.json();
                setIndicatorsMeta(data)
            } 
            catch (err) {
                console.error('Failed to get meta:', err);
                setErrors(['Something went wrong. Please try again later.'])
            } 
            finally {
                setLoading(false);
            }
        };
        getMeta();
    }, []);

    //load organizations (for filtering)
    useEffect(() => {
        const loadOrgs = async () => {
            if(!supportFilter) return;
            try {
                const url = `/api/organizations/?search=${search}`
                const response = await fetchWithAuth(url);
                const data = await response.json();
                setOrgs(data.results);
            } 
            catch (err) {
                console.error('Failed to fetch organizations: ', err)
                setErrors(['Something went wrong, Please try again later.']);
            }
        };
        loadOrgs();
    }, [orgSearch]);

    //load projects (for filtering)
    useEffect(() => {
        const loadProjects = async () => {
            if(!supportFilter) return;
            try {
                const url = `/api/manage/projects/?search=${search}`
                const response = await fetchWithAuth(url);
                const data = await response.json();
                setProjects(data.results);
                setFilters(prev => ({...prev, project: data?.results?.[0]?.id ?? ''}));
            } 
            catch (err) {
                console.error('Failed to fetch organizations: ', err)
                setErrors(['Something went wrong, Please try again later.']);
            }
        };
        loadProjects();
    }, [projectSearch]);

    //update the tasks when one is deleted, triggering a parent update if necessary
    const updateTasks = (id) => {
        const updated = tasks.filter(t => t.id !=id)
        setTasks(updated);
        updateTrigger();
        setSuccess(['Task removed.']);
    }

    //filter out blacklisted tasks (used for hiding tasks already added to interactions)
    const filteredTasks = tasks?.filter(t => !blacklist.includes(t.id)) ?? []

    if(loading) return <ComponentLoading />
    return (
        <div className={styles.tasks} id={'tasks'}>
            <Messages errors={errors} success={success} ref={alertRef} />
            
            <p><i>Search your tasks by name, organization, or project.</i></p>
            
            <IndexViewWrapper onSearchChange={setSearch} page={page} onPageChange={setPage} entries={entries} >
                {supportFilter && <div>
                    <Select options={projects.map(p => ({value: p.id, label: p.name}))} onChange={(v) => setFilters(prev => ({...prev, project: v}))} value={filters.project} search={true} label='Select a Project' onSearchChange={(v) => setProjectSearch(v)} />
                    <Select options={orgs.map(o => ({value: o.id, label: o.name}))} onChange={(v) => setFilters(prev => ({...prev, organization: v}))} value={filters.organization} search={true} label='Select an Organization' onSearchChange={(v) => setOrgSearch(v)} />
                </div>}
                {filteredTasks?.length > 0 ? filteredTasks.map((task) => (
                    <TaskCard task={task} key={task.id} tasks={tasks} 
                        isDraggable={isDraggable} canDelete={canDelete} onDelete={(id) => updateTasks(id)} 
                        callback={callback} forAssessment={forAssessment} meta={indicatorsMeta}
                    />
                )) : <p>No tasks yet.</p>}
            </IndexViewWrapper>
        </div>
    );
}